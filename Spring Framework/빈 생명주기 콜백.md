데이터베이스 커넥션 풀이나 네트워크 소켓처럼 애플리케이션 시작 시점에 미리 연결을 해두거나 종료 시점에 연결을 모두 종료하는 작업을 수행하려면, 객체의 초기화와 종료 작업이 필요하다.   

</br>

setter, 필드 주입의 경우, 객체 생성 -> 의존관계 주입이라는 스프링 빈 라이프 사이클을 가진다.   
(생성자 주입은 파라미터에 스프링 빈이 들어와서 객체가 생성이 되기 때문에 예외임)   

싱글톤일 때의 스프링 빈 이벤트 라이프 사이클   
스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료   

여기서 초기화라는 건 객체를 사용할 수 있도록 준비된 상태 이후에 하는 작업을 말한다. 즉, 의존관계 주입 등의 밑바탕 작업이 끝난 뒤의 작업이다.   
예를 들어, 기본 url 주소를 세팅하는 작업이 초기화라고 볼 수 있다.   

위의 라이프 사이클은 setter, 필드 주입의 경우고 생성자 주입일 경우, 스프링 빈 생성 과정에서 어느정도 의존관계 주입이 일어난다.   

</br>

초기화 콜백: 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출   
소멸전 콜백: 빈이 소멸되기 직전에 호출

</br>

그렇다면, 생성자에서 초기화 작업을 진행하면 안되나?   
생성자는 말그대로 객체를 생성하는 역할에만 충실하는 것이 좋다.   
초기화 작업은 생성된 객체를 통해서 외부 커넥션을 연결하는 등의 무거운 작업이기에, 따로 메서드로 분리하는 것이 추후 유지보수에도 좋다.   
생성자에서 해도 좋은 작업은 객체 내부의 값들을 약간 변경하거나 검증하는 정도의 단순한 경우이다.

</br>

초기화, 소멸전 콜백을 받는 방법

1. InitializingBean, DisposableBean 인터페이스 사용
```java
public class Example implements InitializingBean, DisposableBean {

  ...

  @Override
  public void afterPropertiesSet() throws Exception {
    ...
  }

  @Override
  public void destory() throws Exception {
    ...
  }
}
```

단점   
- 스프링 전용 인터페이스이므로, 코드가 스프링 전용 인터페이스에 의존하게 된다는 점
- 초기화, 소멸 메서드의 이름을 변경할 수 없다는 점
- 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다는 점

 2. 빈 등록 초기화, 소멸 메서드 지정

```java
@Bean(initMethod = "init", destroyMethod = "close")
Bean 메서드

public void init() {
  ...
}

public void close() {
  ...
}
```

특징   
- 자유로운 메서드 이름 설정 가능
- 스프링 빈이 스프링 코드에 의존적이지 않음
- 고드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드 적용 가능

추가 기능
- @Bean의 destroyMethod 속성의 기본값은 "(inferred)" (추론) 이다.
- 대부분의 라이브러리는 close, shutdown이라는 이름의 종료 메서드를 사용하는데, 이 추론 기능이 이들을 자동으로 호출해준다.(말그대로 추론해서 호출)
- 직접 스프링 빈으로 등록하면, 종료 메서드를 따로 적어주지 않아도 잘 동작한다.
- 추론 기능을 사용하기 싫다면, `destroyMethod = ""`처럼 빈 공백을 적어준다.

</br>

3. @PostConstruct, @PreDestroy
> 스프링에서 권고하는 방식, 이 방식을 사용하자!

```java
@PostConstruct
public void init() {
  ...
}

@PreDestroy
public void close() {
 ...
}
```


특징
- 어노테이션 하나만 붙이면 되기에, 매우 편리함
- `javax.annotation.PostConstruct` 패키지를 import하기에, 스프링에 종속적인 기술이 아닌 자바 표준(JSR-250)이다.   
즉, 스프링이 아닌 다른 컨테이너에서도 동작 가능
- 컴포넌트 스캔과 잘 어울림
- **외부 라이브러리에는 적용 불가하기 때문에, 이때는 @Bean의 initMethod, destroyMethod 속성을 이용하자.**
