데이터를 저장하고 관리하는 주요 데이터 자료구조이다.

## 배열(Array)
1. 저장 방식 : 연속된 메모리 공간에 요소들이 순차적으로 저장된다.
2. 접근 시간 : 인덱스를 통한 접근이 빠르다. O(1)의 시간 복잡도를 갖는다.
3. 크기 조정 : 배열의 크기는 변경하기 어렵다. 크기를 변경하기 위해서는 새 배열을 생성하고 데이터를 복사해야 한다.
4. 삽입과 삭제 : 특정 위치에 요소를 삽입하거나 삭제할 때, 해당 위치 이후의 모든 요소를 이동해야 한다. 그렇기 때문에, O(n)의 시간 복잡도를 가질 수 있다.
5. 메모리 사용 : 배열은 요소마다 같은 크기의 메모리를 사용한다. 비어 있는 공간도 메모리를 차지한다.
6. 적합한 상황 : 요소의 개수가 변경되지 않거나 크기 변경이 드물고, 빠른 접근 속도가 중요한 경우에 적합하다.

<br>

## 연결 리스트(Linked List)
1. 저장 방식 : 연결된 노드들이 메모리 여러 곳에 저장된다. 각 노드는 데이터와 다음 노드를 가리키는 포인터로 이루어져 있다.
2. 접근 시간 : 특정 위치로의 접근이 느리다. 최악(첫 번째 노드부터 순차적으로 탐색)의 경우에는 O(n)의 시간 복잡도를 가질 수 있다.
3. 크기 조정 : 크기 변경이 쉽다. 새로운 노드를 추가하거나 기존 노드를 삭제하여 크기를 조정할 수 있다.
4. 삽입과 삭제 : 삽입 및 삭제 작업이 상대적으로 빠르다. 해당 위치 주변 노드들의 연결만 수정하면 된다.
5. 메모리 사용 : 노드마다 다른 크기의 메모리를 사용한다. 필요한 만큼의 메모리를 동적으로 할당하여 사용한다.
6. 적합한 상황 : 요소의 개수가 동적으로 변경되는 경우나 중간 삽입 및 삭제가 빈번한 경우에 적합하다.
   
<br>

***배열은 빠른 접근이 중요한 경우, 링크드 리스트는 동적 크기 조정과 삽입/삭제가 빈번한 경우에 유용하다***

<br>

## 연결 리스트를 이용해서 구현할 수 있는 다른 자료구조들
1. 스택(Stack) : 연결 리스트의 맨 앞에 요소를 추가하고 제거하는 식으로 구현 가능
3. 큐(Queue) : 연결 리스트의 맨 뒤에 요소를 추가하고 제거하는 식으로 구현 가능
4. 데크(Deque) : 연결 리스트의 양 끝에 요소를 추가하고 제거하는 식으로 구현 가능
5. 해시맵(Hash Map)
6. 그래프(Graph)
7. 캐시(LRU Cache)
8. 선형 규(Circular Queue)

등등
