## 힙(Heap)
- 특정한 규칙을 가진 **이진 트리 형태의 자료구조**
- 주로 **최댓값, 최솟값**을 빠르게 찾기 위해 사용
- 보통 **우선순위 큐(Priority Queue)** 를 구현하는 데 사용
- 주로 **배열**을 활용하여 힙을 구현

<br>

## 주요 특징
- ***최대 힙, 최소 힙***
  - ***최대 힙 : 부모 노드의 값이 자식 노드의 값보다 크거나 같은 이진 트리***
  - ***최소 힙 : 반대로 부모 노드의 값이 자식 노드의 값보다 작거나 같은 이진 트리***
- 주로 배열을 사용하여 구현
  - 노드들을 배열의 인덱스에 매핑
  - 배열의 인덱스 0은 루트 노드를 의미
  - 특정 노드의 인덱스가 i라면, 왼쪽 자식 노드는 2i+1, 오른쪽 자식 노드는 2i+2의 인덱스를 가짐
- 삽입
  - 삽입할 요소를 힙의 마지막 위치에 넣고, 부모 노드와 값을 비교하며 힙의 특성(최대, 최소 힙)을 유지
- 삭제
  - 최대 힙에서는 루트 노드를 삭제하면, 최대 값을 삭제
  - 최소 힙에서는 최소 값을 삭제
- 시간 복잡도
  - **삽입과 삭제 연산의 시간 복잡도는 O(log n)**
  - 최대 값, 최소 값은 루트 노드에 위치하므로, 최대,최소 값을 찾는 연산은 O(1)
- **우선순위 큐**를 구현하는데 활용

<br>

## 배열을 통한 힙 구현
***일반적으로 배열의 인덱스를 이용하여 힙의 구조를 표현***
- 루트 노드 : 배열의 첫 번째 인덱스에 저장
- 부모-자식 관계 : 인덱스 i에 저장된 노드의 왼쪽 자식은 2i+1, 오른쪽 자식은 2i+2에 해당하는 인덱스에 저장
- 부모-자식 역관계 : 인덱스 i에 저장된 노드의 부모는 (i-1)/2에 해당하는 인덱스에 저장

<br>

## 힙의 삽입과 삭제
- ***힙의 삽입(Heapify Up)***
  - 삽입할 요소를 힙의 마지막 위치에 추가
  - 그 후, 부모와 비교하여 최대, 최소 힙의 특성에 맞게 요소를 위로 올려줌
  - 이 과정을 부모-자식 간의 관계가 올바르게 정렬될 때까지 반복
- ***힙의 삭제(Heapify Down)***
  - 루트 노드를 제거
  - 제거 후, 힙 배열의 마지막 요소를 루트 노드로 가져옴
  - 그 후, 자식들과 비교하여 최대, 최소 힙의 특성에 맞게 요소를 아래로 내려줌
  - 이 과정을 부모-자식 간의 관계가 올바르게 정렬될 때까지 반복

<br>

## 이진탐색트리와 다르게, 편향이 발생하지 않는 이유
힙은 항상 완전한 이진트리의 형태를 유지하도록 설계되어 있음   
***완전 이진트리의 구조를 유지하기 위해, 각 레벨별로 균형을 맞추면서 노드가 삽입, 삭제되므로 힙의 구조는 편향되지 않고 균형을 유지***

<br>

## 힙 정렬의 시간 복잡도
- **최악, 평균, 최선 상황 모두 시간 복잡도는 O(nlog n)**
- 공간 복잡도는 O(1) -> in-place 정렬
  - in-place 정렬 : 주어진 배열의 원소들을 서로 교환, 이동시켜 정렬을 수행하는 방식
- 정렬 알고리즘 중 빠른 편

<br>

## 힙 정렬의 안정성
- ***힙 정렬은 안정성을 보장하진 않음***
- 안정적인 정렬 알고리즘은 동일한 값의 순서가 변하지 않는 것을 보장해야 하지만, 힙 정렬은 구성 과정에서 **동일한 값의 상대적인 순서가 변경될 수 있기 때문에** 안정성을 보장하지 않음
- 안정성이 필요한 경우, 다른 정렬 알고리즘을 고려해보아야 함
