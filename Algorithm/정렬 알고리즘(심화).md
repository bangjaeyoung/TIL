## 퀵 정렬과 병합 정렬 비교
- 퀵 정렬은 평균적으로 병합 정렬보다 빠르지만, 최악의 경우 병합 정렬보다 성능이 떨어질 수 있음
- 병합 정렬은 추가 메모리 사용량이 크다는 단점이 있지만, 항상 일정한 성능을 유지하고 안정적인 정렬을 보장함
- 퀵 정렬은 불균형 분할에 의해 성능이 저하될 수 있지만, 병합 정렬은 항상 두 개의 배열로 나누므로 불균형 분할에 영향을 받지 않음

**대부분의 경우, 퀵 정렬이 더 빠른 성능을 보이지만, 안정성과 일관된 성능을 원할 경우 병합 정렬을 택하는 게 좋음**

<br>

## 퀵 정렬에서 시간 복잡도 O(n^2)이 걸리는 예시와 개선 방법
**피봇(pivot)을 항상 최솟값이나 최댓값으로 선택하거나, 이미 정렬되거나 거의 정렬된 배열을 정렬할 때 시간 복잡도 O(N^2)이 걸릴 수 있음**   
<br>
만약 배열이 이미 정렬되어 있는 경우에, 퀵 정렬은 항상 최소 또는 최대값을 피봇으로 선택하면서 분할을 함.   
각 단계마다 하나의 원소만 올바른 위치로 이동하므로 퀵 정렬의 장점을 활용하지 못하고, 분할 과정만 반복되어 O(N^2)의 시간 복잡도가 발생할 수 있음

<br>

개선 방법
- **랜덤한 피봇 선택**
  - 최악의 경우에 대한 가능성을 줄이고 평균적인 경우의 성능을 향상시킬 수 있음
- **중간값 피봇 선택**
  - 배열의 첫 번째, 가운데, 마지막 원소를 비교하여 중간값을 피봇으로 선택
- **삼중 피봇 퀵 정렬**
  - 배열을 세 부분으로 나누는 방식으로 여러 개의 피봇을 사용하여 분할

**위 3가지 피봇 선택 방법을 사용하면 퀵 정렬의 성능을 개선하고 최악의 경우에도 O(n log(n))의 시간 복잡도를 유지할 수 있음**

<br>

## 안정적인 정렬 알고리즘
**안정적인 정렬이란 정렬 알고리즘을 적용할 때 동일한 값(키)을 가진 원소들의 상대적인 순서가 정렬 전과 동일하게 유지되는 속성**   
만약 두 개의 원소 A와 B가 있고 A가 B보다 앞에 있었다면, 정렬 후에도 A는 B보다 앞에 위치해야 함

안정적인 정렬 알고리즘
- **병합 정렬**
  - 분할 정복 방식을 이용하여 상대적인 순서를 유지
- **삽입 정렬**
  - 각 원소를 정렬된 부분 배열에 삽입하면서 정렬하는 방식으로, 동일한 값들의 상대적인 순서를 유지
- **버블 정렬**
  - 인접한 원소를 계속해서 비교하면서 정렬하는 방식으로, 같은 값의 원소들이 교환될 때 순서를 유지
 
퀵 정렬과 힙 정렬 같은 경우는 안정적인 정렬 알고리즘이 아님 = 동일한 값의 원소들의 순서가 바뀔 수 있음

<br>

## 재귀를 사용하지 않고 병합 정렬을 구현하는 방법
- 재귀 없이 반복문을 사용하여 병합 정렬을 구현하는 방법을 **"Bottom-Up Merge Sort"** 또는 **"Iterative Merge Sort"** 라고 함
- 공간 복잡도를 줄이기 위해 사용됨

```java
import java.util.Arrays;

public class MergeSortIterative {

    public static void mergeSort(int[] arr) {
        int n = arr.length;
        int width = 1;  // Merge의 너비
        while (width < n) {
            for (int i = 0; i < n; i += 2 * width) {
                int leftStart = i;
                int mid = i + width;
                int rightStart = i + 2 * width;
                int leftEnd = Math.min(mid, n);
                int rightEnd = Math.min(rightStart, n);

                merge(arr, leftStart, mid, rightStart, leftEnd, rightEnd);
            }
            width *= 2;
        }
    }

    public static void merge(int[] arr, int leftStart, int mid, int rightStart, int leftEnd, int rightEnd) {
        int[] result = new int[rightEnd - leftStart];
        int leftIdx = leftStart;
        int rightIdx = mid;
        int resultIdx = 0;

        while (leftIdx < leftEnd && rightIdx < rightEnd) {
            if (arr[leftIdx] < arr[rightIdx]) {
                result[resultIdx++] = arr[leftIdx++];
            } else {
                result[resultIdx++] = arr[rightIdx++];
            }
        }

        while (leftIdx < leftEnd) {
            result[resultIdx++] = arr[leftIdx++];
        }

        while (rightIdx < rightEnd) {
            result[resultIdx++] = arr[rightIdx++];
        }

        System.arraycopy(result, 0, arr, leftStart, result.length);
    }

    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        mergeSort(arr);
        System.out.println(Arrays.toString(arr));  // 정렬된 배열 출력
    }
}
```

***배열의 너비에 따라 분할하고, merge 함수를 사용하여 정렬된 배열을 병합하는 로직***

<br>

## 기수 정렬(Radix Sort)
- 정수나 문자열과 같은 키(key)를 가진 데이터를 정렬하는 데 사용되는 비교 없이 정렬
- 키의 자릿수를 기준으로 데이터를 여러 번 정렬하는 방식을 사용하여 전체 데이터를 정렬

<br>

작동 방식
- 가장 낮은 자릿수(일의 자리)부터 시작하여 가장 높은 자릿수(최대 자릿수)까지 반복
- 각 자릿수에 대해 숫자들을 버킷(0부터 9까지의 숫자를 저장할 수 있는 배열)에 분배   (ex. 일의 자릿수에 따라 숫자들을 0부터 9까지의 버킷에 나누어 넣음)
- 버킷에 있는 숫자들의 순서대로 배열에 다시 정렬. 이때, 버킷의 순서는 0부터 9까지이므로 작은 숫자부터 큰 숫자 순으로 정렬됨
- 위의 단계를 가장 높은 자릿수까지 반복하여 정렬을 완료시킴

**기수 정렬의 시간 복잡도는 O(nk). 여기서 n은 배열의 크기이고, k는 키의 최대 자릿수**   
**기수 정렬은 키의 자릿수가 많을 때 효과적인 알고리즘, 데이터의 크기와 키의 자릿수가 큰 경우 메모리 사용량이 크게 증가할 수 있음**   
**음수 값을 정렬할 때에도 적절한 처리가 필요하며, 실수 값과 같은 비정수 값들에는 적용하기 어려운 경우가 있음**

<br>

## 버블 정렬, 선택 정렬, 삽입 정렬의 속도 비교
- 버블 정렬
  - 시간 복잡도 : 최선/평균/최악 모두 O(n^2)
  - 원소가 올바른 위치에 도달할 때까지 인접한 두 원소를 비교하면서 스왑하는 방식으로 동작
  - 비교적 간단하지만, 큰 배열이나 최적화되지 않은 경우 성능이 좋지 않음. 최악의 경우에도 항상 두 원소를 비교하므로 비효율적
- 선택 정렬
  - 시간 복잡도 : 최선/평균/최악 모두 O(n^2)
  - 가장 작은 값을 선택하여 배열의 맨 앞부터 정렬된 부분을 만들어 나가는 방식으로 동작
  - 버블 정렬과 유사한 성능을 가지며, 교환 연산의 수가 비교적 적지만 여전히 비효율적
- 삽입 정렬
  - 시간 복잡도 : 최선(거의 정렬된 경우) O(n), 평균/최악 O(n^2)
  - 이미 정렬된 부분 배열에 새로운 원소를 삽입하면서 정렬하는 방식으로 동작
  - 작은 배열이나 거의 정렬된 배열에 효과적, 상대적으로 데이터의 이동이 적기 때문에 일부 상황에서 빠른 성능을 보일 수 있음

**버블 정렬과 선택 정렬은 모두 최악의 경우에도 항상 O(n^2)의 시간 복잡도를 가지므로 큰 배열에서는 비효율적**   
**삽입 정렬은 최선의 경우에 O(n) 시간 복잡도를 가지며, 거의 정렬된 경우나 작은 배열에서 효율적임. 그러나 큰 배열이나 최악의 경우에는 O(n^2)의 성능을 가질 수 있음**   
**일반적으로는 삽입 정렬이 버블 정렬, 선택 정렬보다 선호되는 알고리즘**   

<br>

### 위 3가지 정렬 알고리즘 중에서, 거의 정렬되거나 이미 정렬된 배열의 경우 각각의 성능은 어떨까?
- 버블 정렬
  - 비교적 작은 스왑 연산을 통해 이미 정렬된 부분은 빠르게 완성될 수 있음
  - 하지만, 전체 배열을 스캔하면서 비효율적인 비교 연산을 수행하기 때문에 최적의 선택은 아님
- 선택 정렬
  - 비교 연산은 동일하게 발생하며, 선택 단계에서 작은 값을 찾아서 위치를 교환해야 함
  - 이런 상황에서 선택 정렬의 성능은 비효율적일 가능성이 높음
- **삽입 정렬**
  - 삽입 정렬은 거의 정렬되거나 이미 정렬된 경우에 가장 좋은 성능을 보이는 경향이 있음
  - 이미 정렬된 부분에 새로운 원소를 삽입하면서 작은 연산만 수행하면 되므로, 최선의 경우에는 O(n)의 시간 복잡도로 작동

**거의 정렬되거나 이미 정렬된 경우에는 삽입 정렬은 가장 빠른 성능을 보일 가능성이 큼**

<br>

## Java에서 사용되는 정렬 알고리즘
- Java의 정렬 라이브러리인 `Arrays.sort()`와 `Collections.sort()`는 **팀 정렬(Tim Sort)** 를 사용함
 - **팀 정렬은 병합 정렬과 삽입 정렬을 결합하여 구현한 안정적이고 효율적인 알고리즘**
- 이외에도 힙 정렬, 선택 정렬, 버블 정렬을 사용할 수 있음
  - Java에서 직접 구현하거나 추가 라이브러리를 이용해서 사용 가능

<br>

## 정렬해야 하는 데이터는 50GB이고 메모리가 4GB라면, 어떤 방식으로 정렬을 진행할 수 있을까?
- 전체 데이터를 메모리에 한 번에 올리는 것은 불가
- 대부분의 정렬 알고리즘은 추가 메모리 공간을 사용하여 정렬 중간 과정을 처리하는데, **메모리 제한이 있는 경우에는 외부 정렬(External Sorting) 알고리즘을 사용해야 함**

<br>

**외부 정렬**
- 대용량의 데이터를 메모리에 올리지 않고도 효율적으로 정렬하는 방법을 제공
- 대표적으로 **"병합 정렬 + 분할 정복"** 방식을 사용하는 외부 정렬 알고리즘이 존재

<br>

**병합 정렬 + 분할 정복 방식의 외부 정렬**
- 초기에는 입력 데이터를 메모리 용량에 맞게 나누어 읽어들임. 이때, 메모리 내에서 부분적으로 정렬하여 임시 파일에 저장
- 임시 파일들을 병합하면서 정렬된 부분을 만들어 나감. 이때, 병합 과정에서도 메모리 내에서 일부만을 처리하며, 정렬된 결과를 다시 임시 파일에 저장
- 병합 과정을 반복하여 정렬이 완료될 때까지 계속 진행

**외부 정렬 알고리즘을 선택할 때는 특히 데이터의 형식, 정렬되어야 하는 속성, I/O 성능 등을 고려해야 함**   
**대량의 데이터를 정렬해야 하는 경우에는 보다 복잡한 알고리즘들을 사용하게 될 수 있으므로, 데이터베이스 시스템이나 외부 정렬 라이브러리를 활용하는 것도 고려해볼 수 있음**
