## 시간 복잡도
시간 복잡도(Time Complexity)는 알고리즘의 절대적인 실행 시간을 나타내는 것이 아닌,
<br>
<b>알고리즘을 수행하는 데에 연산들이 몇 번 이루어지는 지를 숫자로 표기하는 것입니다.</b>

연산의 실행 횟수는 보편적으로 변하지 않는 상수가 아니라 입력한 데이터의 개수를 뜻하는 n에 따라 변하게 됩니다.
<br>
<b>연산의 실행 횟수를 입력한 데이터의 개수(n)의 함수로 나타낸 것을 시간 복잡도 함수라고 부르며, T(n)으로 표기합니다.</b>

<br>

## 공간 복잡도
공간 복잡도(Space Complexity)는 프로그램이 실행되고 완료되는데까지 필요한 자원 공간의 양을 말합니다.
<br>
<b>총 공간 요구 = 고정 공간 요구 + 가변 공간 요구로 나타내며, S(P) = c + Sp(n)으로 표기합니다.</b>

고정 공간은 입력과 출력의 횟수와 관계없는 공간을 말합니다. ex) 코드 저장 공간, 상수, 단순 변수, ...
<br>
가변 공간은 코드 실행 중 동적으로 필요한 공간을 말합니다. ex) 특정 클래스 호출 시, 그 클래스에 있는 변수를 위한 공간, ...

<br>

## Big-O / Big-Theta / Big-Omega
- Big-O : 점근적 상한을 나타내는 표기 (최악, 시간 복잡도를 나타내는 데 주로 사용됨)
- Big-Omega : 점근적 하한을 나타내는 표기 (최상)
- Big-Theta : 위 두 표기가 같을 때 사용하는 표기 (평균)

<br>

## Big-O 표기법을 주로 사용하는 이유는?

1. 평균을 나타내는 Big-Theta 표기법이 가장 이상적이고 정확하지만 그 만큼 도출해내기가 어렵습니다.
2. Big-O 표기법은 알고리즘의 최악의 경우일 때의 성능을 예측할 수 있습니다.
3. 가장 낮은 차수인 항과 계수를 제외시켜 표시하기 때문에, 주요한 연산(가장 높은 차수인 항)에만 초점을 맞추어 표현해줍니다.
4. 시간 복잡도를 표기하는 가장 통용되는 표기법이 Big-O 표기법입니다.

<br>

## O(1)은 O(N^2) 보다 무조건적으로 빠른가?
O(1)은 O(N^2)보다 빠릅니다. 하지만, 무조건적이진 않습니다.
<br>
시간 복잡도 표기법에서 O(1)은 상수 시간을 나타내며, 입력 크기에 관계없이 일정한 시간만큼 수행됩니다.

반면에, O(N^2)은 입력 크기 N에 대해 N의 제곱에 비례하는 시간이 소요됩니다.
<br>
입력 크기가 증가할수록 알고리즘의 수행 시간이 기하급수적으로 증가함을 의미합니다.

알고리즘의 성능을 평가할 때에는 상수 계수, 실제 하드웨어의 영향 등을 고려해야 하므로, 상황에 따라서는 O(N^2) 알고리즘이 더 효율적일 수도 있습니다.
<br>
하지만 일반적인 경우에는 O(1) 알고리즘이 더 효율적입니다.
